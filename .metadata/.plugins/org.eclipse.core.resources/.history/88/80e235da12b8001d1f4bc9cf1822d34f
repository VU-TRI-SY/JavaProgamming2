package tut4;

public class Arrays {

	public int countNegatives(int[] arr) {
		int count = 0;
		for(int i = 0; i < arr.length; i++) {
			if(arr[i] < 0) {
				count ++;
			}
		}
		
		return count;
	}
	
	public int countEvens(int[] arr) {
		int count = 0;
		for(int i = 0; i < arr.length; i++) {
			if(arr[i] % 2 == 0) {
				count ++;
			}
		}
		
		return count;
	}
	
	public double[] divArray(double[] arr, double div) {
		//res[i] = arr[i] / div
		int len = arr.length;
		double[] res = new double[len];
		for(int i = 0; i < len; i++) {
			res[i] = arr[i] / div;
		}
		return res;
	}
	
	public int min(int[] arr) {
		int minVal = arr[0];
		for(int i = 1; i < arr.length; i++) {
			if(arr[i] < minVal) {
				minVal = arr[i];
			}
		}
		return minVal;
	}
	
	public boolean isAscSorted(int[] arr) {
		for(int i = 0; i <= arr.length-2; i++) {
			if(arr[i] > arr[i+1]) {
				return false;
			}
		}
		return true;
	}
	
	public int length(char[] arr) {
		int len = 0;
	    for (int i = 0; i < arr.length; i++) {
	        if (arr[i] == '\u0000') {
	            break;
	        }else {
	        	len++;
	        }
	    }
	    return len;
	}
	
	public double[] sortDoubleArray(double[] b) {
		int len = b.length;
		boolean check = true; //check = true để vòng while sẽ được chạy ít nhất 1 lần
		while(check == true) {
			check = false; //trong mỗi lần đi qua các phần tử của mảng và so sánh b[i] vs b[i+1]
			//thì phải reset check = false thể hiện không hề tồn tại 2 phần tử cạnh nhau mà phá vỡ order tăng dần 
			for(int i = 0; i <= len-2; i++) {
				if(b[i] > b[i+1]) {
					double temp = b[i];
					b[i] = b[i+1];
					b[i+1] = temp;
					check = true;
				}
			}
		}
		return b;
	}
	
	public double median(double[] arr) {
		//b1: tạo ra mảng b là mảng copy của arr
		//b2: sắp xếp lại mảng b theo thứ tự tăng dần
		//b3: tìm median trên mảng b và return kết quả
		int len = arr.length;
		double[] b = new double[len];
		for(int i = 0; i < len; i++) {
			b[i] = arr[i];
		}
		
		//bubble sort
		b = sortDoubleArray(b);
		//----------------------------------------------------

		double med;
	    if (len % 2 == 0) {
	    	med = (arr[len/2] + arr[len/2 - 1]) / 2;
	    } else {
	    	med = arr[len/2];
	    }
	    return med;
		
	}
	
	public String compare(double[] a, double[] b) {
		String result = "";
	    int lenA = a.length;
	    int lenB = b.length;
	    int i = 0, j = 0;
	    
	    double[] arr = new double[lenA];
	    for(int id = 0; id < lenA; id++) {
	    	arr[id] = a[id];
	    }
	    
	    double[] brr = new double[lenB];
	    for(int id = 0; id < lenA; id++) {
	    	brr[id] = b[id];
	    }
	    
	    arr = sortDoubleArray(arr);
	    brr = sortDoubleArray(brr);
	    
	    //check: arr is subset of brr
	    while(i < lenA && j < lenB) {
	    	if(arr[i] == brr[j]) {
	    		i++;
	    		j++;
	    	}else {
	    		if(arr[i] > brr[j]) {
	    			j++;
	    		}else { //arr[i] < brr[j]
	    			break;
	    		}
	    	}
	    }
	    
	    if(i == lenA) {
	    	result = "A is subset of B";
	    }

	    
	   //check: brr is subset of arr
	    i = 0; j = 0;
	    while(i < lenA && j < lenB) {
	    	if(arr[i] == brr[j]) {
	    		i++;
	    		j++;
	    	}else {
	    		if(brr[j] > arr[i]) {
	    			i++;
	    		}else { //brr[j] < arr[i]
	    			break;
	    		}
	    	}
	    }
	    
	    if(j == lenB) {
	    	result = "B is subset of A";
	    }
	    
	    //check: a is intersection with b
	    i = 0; j = 0;
	    while(i < lenA && j < lenB) {
	    	if(arr[i] == brr[j]) {
	    		i++; j++;
	    	}else {
	    		if(arr[i] < brr[j]) {
	    			i++;
	    		}else { //arr[i] > brr[j]
	    			j++;
	    		}
	    	}
	    }
	    
	    
	    
	    return result;
	}
	
	public int[] freq(double[] arr) {
		
		return new int[10];
	}
}
